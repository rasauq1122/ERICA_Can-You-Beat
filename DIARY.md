# 개발 일지
**4일차 : 2019-12-04**  
  
>오늘은 원래 사용자 입력으로 **add 명령어가 들어올 때의 문법 확인 기능**을 구현하려고 했다.  
그 과정의 일련으로 **다른 명령어가 들어올 때의 문법 확인 기능**을 담은 **check 파일**을 만들었다.  
그러다가 이미 만들어 둔 **note 파일**에 담긴 메소드들의 기능에서 **명령어 문법 확인 작업**을 분리하여  
**check 파일**에 그러한 메소드를 담아서 이원화를 한 다음 시작해야겠다고 생각하였다.  
>
>그런데 이해할 수 없는 오류가 발생하였다.  
현재 연결 중인 단어장의 이름을 기억하는 변수인 **now_note_name** 을  
**note 파일**에서 단어장에 연결하는 메소드인 **connectnote()** 을 통해 변경시켜도  
**check_note 파일**에서 **disconnect()** 메소드를 실행하기 위해 올바른 입력인지 확인하는  
**check_disconnect()** 메소드에서 **now_note_name**에 접근하려고 하자  
변경사항이 적용되지 않은 변수의 값을 확인하여 프로그램이 오류를 내는 것이었다.  
>
>도대체 왜 변경사항이 적용되지 않는 지 이해할 수 없었다.  
왜 이런 일이 발생하는 지 알기 위해 각 파일에서 디버깅을 해본 결과  
**note 파일**에서만 그 변경사항이 저장되어 활용할 수 있었고  
원래 **now_note_name** 변수를 담고 있는 **tool 파일**에서도 변경사항이 저장되지 않은 걸 확인할 수 있었다.  
>  
>아무래도 **한 파일 내에서 일어난 변수의 변화는 그 파일 내에서만 저장**되는 모양이었다.  
**note 파일**에서 **now_note_name** 을 반환이나 수정할 수 있는 메소드를 만든 후  
다른 파일에서 import 하면 사용할 수 다른 파일에서도 **now_note_name** 에 접근할 수 있긴 했지만  
그렇게 하면 import 관계가 꼬여 나중에 돌이킬 수 없는 오류로 돌아올 것 같았다.  
>  
>따라서 **변수가 아닌 파일로 관리**하기로 하였다.  
파일로 관리하면 파일 내용을 쉽게 가져올 수도 있고 설정할 수도 있다.  
그러한 메소드를 **tool 파일**에서 구현하므로써 이 오류를 해결하였다.  
>  
>오늘 원래 구현하려고 했던 **add 명령어가 들어올 때의 문법 확인 기능**은 내일 구현할 예정이다.
   
> 2019-12-05 : 오타 수정 - 2번째 문단 4번째 줄에서 check-note 를 check_note 로 수정 
  
---
**5일차 : 2019-12-05**  
  
>일단 어제 하기로 하였던 **add 명령어가 들어올 때의 문법 확인 기능**을 구현하기 전에  
**새로운 단어장을 만드는 메소드**의 이름은 **addnote**인 것에 반해  
**단어장에 새 단어를 추가하는 메소드**의 이름은 **add**라서  
이에 대해 일관적으로 보이게 하기 위해서 메소드의 이름을 **addword**로 수정하였다.  
>  
>또한 파일의 이름도 일관적으로 보이게 수정하였다.  
**사용자 입력으로 들어온 명령어의 문법이 맞는지 확인하는 메소드**가 담긴 파일의 이름 앞에는 **check_** 를  
**명령어의 의미를 직관적으로 하기 위해 명령어를 복호화하는 메소드**가 담긴 파일의 이름 앞에는 **decode_** 를  
**복호화된 명령어의 데이터를 받아 직접 명령어를 수행하는 메소드**가 담긴 파일의 이름 앞에는 **execute_** 를   
붙이게 했다.  
>  
>파일 이름의 '_' 뒤에 붙는 문자열은  
그 **파일에 담긴 메소드가 무엇을 다루고 있는 지**에 따라 달라진다.  
현재까지는 **note (단어장)** , **word (단어)** 밖에 없다.  
>
>일단 **addword 명령어**의 문법을 확인하는 메소드를 만들기 전에  
먼저 **addword 명령어**가 어떤 형식이 올바른 형식인지에 대해 말해야 할 필요가 있다.  
다음은 그에 대한 예제이다.  
>>[예제 1] addword apple -n 사과 -tag 과일 -v 사과하다, 사죄하다 -a 사과가 먹고 싶은; 사과로 만들어진 
>  
>단어장에 추가하고자 하는 영단어를 addword 다음에 빈칸을 두고 입력한 후  
그 영단어의 뜻을 옵션을 달아 추가한다. 이때 **옵션은 품사의 약어로 입력**한다. ( ex. -n , -a , … )  
영어 품사에 대한 추가 설명은 [이 곳](https://dreamhepatica.tistory.com/entry/8%ED%92%88%EC%82%AC%EC%9D%98-%EC%95%BD%EC%96%B4)을 참고할 것을 추천한다.
>  
>그 외 **tag 옵션**도 있다.  
기본적으로 바로 전에 온 **영단어의 뜻에 태그를 다는 역할**을 하지만  
영단어에 바로 뒤에 이어 붙여서 **영단어 자체에 태그를 다는 것도 가능**하다.  
>  
>영단어의 뜻은 [예제 1]에서 '사과하다', '사죄하다' 와 같이 의미가 비슷한 것들은 **쉼표**로 구분하며  
'사과가 먹고 싶은', '사과로 만들어진' 과 같이 의미가 다소 다른 것들은 **세미콜론**으로 구분한다.  
>  
>필자가 **check_addword 메소드**를 구현하면서 크게 신경쓴 부분은 다음과 같다.  
>1. 영단어가 입력되어야 한다.  
>2. 최소 하나의 뜻은 갖고 있어야 한다. 
>3. 같은 의미로, 영단어가 태그만 갖고 있지는 않아야 한다.
>4. 사전에 허용한 옵션만 들어와야 한다.
>  
>추가로 **addword 명령어로 직접 영단어를 단어장에 추가할 수 있는 기능**도 구현하고자 했지만  
이 프로젝트 말고도 마감이 가까운 과제가 있으므로 여기까지만 하고 내일로 미루도록 하겠다.
   
> 2019-12-07 : 오타 수정 - 6번째 문단 2번째 줄에 강조 부분을 늘림 
  
---
**13일차 : 2019-12-13**  
  
>갑자기 여러가지 시험과 슬럼프가 겹쳐 최근 개발을 하는 둥 마는 둥 하였다.  
슬럼프에 빠진 이유는 바로 **addword 명령어** 때문이었다.  
  
>5일차 일지에도 나와 있듯이, **addword 명령어**는 **접속 중인 단어장에 단어를 추가하는 명령어**이다.    
당시에 구현한 내용은 **STAR에 단어를 추가**하고 그 단어를 **접속 중인 단어장에도 기록**하는 방식이었다.  
이 방식에는 문제가 있는데, 이미 **STAR에 등록된 단어이든 아니든** 고려하지 않고 **항상 STAR에 등록**한다는 것이다.  
이 단 하나의 문제를 해결하는 것은 굉장히 간단하다. 예상했듯이, 이미 **등록된 단어는 등록할 수 없게끔** 코드를 짜면 된다.  
  
>하지만 그렇게 고쳤을 때, 당연하지만 이미 **STAR에 등록된 단어에 대해서는 더 이상 추가를 할 수 없다**는 것이 부가적인 문제였다.  
한 번 등록된 단어에 대해서는 **더 이상 새로운 뜻을 붙일 수도 없고 다른 단어장에서 그 단어를 등록할 수 없었다.**  
그렇기 때문에, 이에 대한 **경우를 모두 처리**해야 하는 addword 명령어를 만드는 것은 상당히 버거웠다.  
  
>굉장히 오래 어떻게 처리를 해야할 지에 대해서 고민해도 좋은 방법이 떠오르지 않았다.  
그러다가 12일차에 나 자신도 굉장히 만족할 수 있는 방법을 떠올렸다.  
바로 **addword 명령어**로 모든 상황에 맞춰 적재적소로 대응하게 끔 하는 것이 아니라  
**addword 명령어**를 **크게 세 가지 명령어로 나누어** 어떻게 사용할 지는 사용자에게 맡기는 것이었다.  

>나는 **addword 명령어**를 **newword 명령어, appendword 명령어, pullword 명령어**로 나누었다.  
**newword 명령어**는 기존의 **addword 명령어**처럼 STAR에 등록되지 않았던 단어를 등록하는 명령어다.  
**appendword 명령어**는 이미 STAR에 등록된 단어에 **새로운 뜻을 추가**하는 명령어다.  
**pullword 명령어**는 이미 STAR에 등록된 단어를 **단어장에서 끌어다 불러올 수 있는** 명령어다.  
이 세 가지 명령어를 적절히 합치면 원래 만들고자 했던 **addword 명령어**를 만들 수 있을 것이라고 생각은 되지만,  
프로젝트의 마감일이 얼마 남지 않았으므로 이는 남은 시간에 따라 구현할 지 말 지를 결정할 것이다.
  
>이제 내가 **13일차**에 개발한 것에 대해 말하겠다.  
오늘 나는 **viewword 명령어**를 구현했다. 간단히 설명하면 **단어의 뜻들을 CUI로 사용자에게 보여주는 명령어**다.  
솔직히 굉장히 쉽게 만들 수 있을 줄 알았는데, 의외의 난관에 봉착했다.  
바로 '**한글**'이었다.  

>내 모니터에서는 우분투의 해상도를 짤리지 않고 가장 크게 맞출 수 있는 해상도가 **1440 x 900** 이라서  
그 해상도에 맞춰서 가장 넓적하게 사용하고자 했다.
그 해상도에서 터미널을 전체화면으로 하면 **한 줄에 151 글자**까지 쓸 수 있었는데,
**한글은 영어나 숫자의 2배의 공간을 잡아먹는 것이었다.** 
  
>사용자 입력으로 들어온 문자열에 한글이 있는 지 확인할 수 있는 방법은 없는 것처럼 보였다.  
파이썬이 아무리 친절하게 다양한 메소드를 제공한다고 하더라도,  
**주어진 입력이 한글인지 확인하는 메소드는 제공하지 않을 것이라고 생각했기 때문이다.**  
  
>결론부터 말하자면, 한글을 확인할 수 있는 방법이 있었다.  
바로 **정규표현식을 활용**하는 것이었다.  
간략히 설명하자면, [가-힣] 이라는 정규표현식은 모든 한글의 음절을 포함하기 때문에,  
이 정규표현식을 만족하면 한글이므로, 확인할 수 있는 것이다.  
  
>그래서 하는 김에 기존에 **영단어나 영단어의 뜻에 대한 정규표현식**을 만들어  
내가 원하는 입력만 받을 수 있도록 개선하였다.  
  
>이번 주말에는 **단어에 관련된 명령어**를 모두 구현하고,  
**실제로 명령어를 입력**할 수 있게끔 하도록 할 예정이다.  
  
---
