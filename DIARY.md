# 개발 일지
**4일차 : 2019-12-04**  
  
>오늘은 원래 사용자 입력으로 **add 명령어가 들어올 때의 문법 확인 기능**을 구현하려고 했다.  
그 과정의 일련으로 **다른 명령어가 들어올 때의 문법 확인 기능**을 담은 **check 파일**을 만들었다.  
그러다가 이미 만들어 둔 **note 파일**에 담긴 메소드들의 기능에서 **명령어 문법 확인 작업**을 분리하여  
**check 파일**에 그러한 메소드를 담아서 이원화를 한 다음 시작해야겠다고 생각하였다.  
>
>그런데 이해할 수 없는 오류가 발생하였다.  
현재 연결 중인 단어장의 이름을 기억하는 변수인 **now_note_name** 을  
**note 파일**에서 단어장에 연결하는 메소드인 **connectnote()** 을 통해 변경시켜도  
**check_note 파일**에서 **disconnect()** 메소드를 실행하기 위해 올바른 입력인지 확인하는  
**check_disconnect()** 메소드에서 **now_note_name**에 접근하려고 하자  
변경사항이 적용되지 않은 변수의 값을 확인하여 프로그램이 오류를 내는 것이었다.  
>
>도대체 왜 변경사항이 적용되지 않는 지 이해할 수 없었다.  
왜 이런 일이 발생하는 지 알기 위해 각 파일에서 디버깅을 해본 결과  
**note 파일**에서만 그 변경사항이 저장되어 활용할 수 있었고  
원래 **now_note_name** 변수를 담고 있는 **tool 파일**에서도 변경사항이 저장되지 않은 걸 확인할 수 있었다.  
>  
>아무래도 **한 파일 내에서 일어난 변수의 변화는 그 파일 내에서만 저장**되는 모양이었다.  
**note 파일**에서 **now_note_name** 을 반환이나 수정할 수 있는 메소드를 만든 후  
다른 파일에서 import 하면 사용할 수 다른 파일에서도 **now_note_name** 에 접근할 수 있긴 했지만  
그렇게 하면 import 관계가 꼬여 나중에 돌이킬 수 없는 오류로 돌아올 것 같았다.  
>  
>따라서 **변수가 아닌 파일로 관리**하기로 하였다.  
파일로 관리하면 파일 내용을 쉽게 가져올 수도 있고 설정할 수도 있다.  
그러한 메소드를 **tool 파일**에서 구현하므로써 이 오류를 해결하였다.  
>  
>오늘 원래 구현하려고 했던 **add 명령어가 들어올 때의 문법 확인 기능**은 내일 구현할 예정이다.
   
> 2019-12-05 : 오타 수정 - 2번째 문단 4번째 줄에서 check-note 를 check_note 로 수정 
  
---
**5일차 : 2019-12-05**  
  
>일단 어제 하기로 하였던 **add 명령어가 들어올 때의 문법 확인 기능**을 구현하기 전에  
**새로운 단어장을 만드는 메소드**의 이름은 **addnote**인 것에 반해  
**단어장에 새 단어를 추가하는 메소드**의 이름은 **add**라서  
이에 대해 일관적으로 보이게 하기 위해서 메소드의 이름을 **addword**로 수정하였다.  
>  
>또한 파일의 이름도 일관적으로 보이게 수정하였다.  
**사용자 입력으로 들어온 명령어의 문법이 맞는지 확인하는 메소드**가 담긴 파일의 이름 앞에는 **check_** 를  
**명령어의 의미를 직관적으로 하기 위해 명령어를 복호화하는 메소드**가 담긴 파일의 이름 앞에는 **decode_** 를  
**복호화된 명령어의 데이터를 받아 직접 명령어를 수행하는 메소드**가 담긴 파일의 이름 앞에는 **execute_** 를   
붙이게 했다.  
>  
>파일 이름의 '_' 뒤에 붙는 문자열은  
그 **파일에 담긴 메소드가 무엇을 다루고 있는 지**에 따라 달라진다.  
현재까지는 **note (단어장)** , **word (단어)** 밖에 없다.  
>
>일단 **addword 명령어**의 문법을 확인하는 메소드를 만들기 전에  
먼저 **addword 명령어**가 어떤 형식이 올바른 형식인지에 대해 말해야 할 필요가 있다.  
다음은 그에 대한 예제이다.  
>>[예제 1] addword apple -n 사과 -tag 과일 -v 사과하다, 사죄하다 -a 사과가 먹고 싶은; 사과로 만들어진 
>  
>단어장에 추가하고자 하는 영단어를 addword 다음에 빈칸을 두고 입력한 후  
그 영단어의 뜻을 옵션을 달아 추가한다. 이때 **옵션은 품사의 약어로 입력**한다. ( ex. -n , -a , … )  
영어 품사에 대한 추가 설명은 [이 곳](https://dreamhepatica.tistory.com/entry/8%ED%92%88%EC%82%AC%EC%9D%98-%EC%95%BD%EC%96%B4)을 참고할 것을 추천한다.
>  
>그 외 **tag 옵션**도 있다.  
기본적으로 바로 전에 온 **영단어의 뜻**에 태그를 다는 역할을 하지만  
영단어에 바로 뒤에 이어 붙여서 **영단어 자체에 태그를 다는 것도 가능**하다.  
>  
>영단어의 뜻은 [예제 1]에서 '사과하다', '사죄하다' 와 같이 의미가 비슷한 것들은 **쉼표**로 구분하며  
'사과가 먹고 싶은', '사과로 만들어진' 과 같이 의미가 다소 다른 것들은 **세미콜론**으로 구분한다.  
>  
>필자가 **check_addword 메소드**를 구현하면서 크게 신경쓴 부분은 다음과 같다.  
>1. 영단어가 입력되어야 한다.  
>2. 최소 하나의 뜻은 갖고 있어야 한다. 
>3. 같은 의미로, 영단어가 태그만 갖고 있지는 않아야 한다.
>4. 사전에 허용한 옵션만 들어와야 한다.
>  
>추가로 **addword 명령어로 직접 영단어를 단어장에 추가할 수 있는 기능**도 구현하고자 했지만  
이 프로젝트 말고도 마감이 가까운 과제가 있으므로 여기까지만 하고 내일로 미루도록 하겠다.
  
---
